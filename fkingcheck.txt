Universal Implementation Analysis Checklist
Phase 1: Project Understanding

 Read database schema documentation for data structure
 Review project guide for general context and architecture
 Analyze backend API endpoints and availability
 Examine current component styling and CSS class patterns
 Identify data flow patterns and state management approach

Phase 2: Component Analysis
Target Component Groups

 Analyze current component structure and styling
 Document existing CSS classes and their exact order
 Identify data fetching and state management patterns
 Map component hierarchy and dependencies
 Review component-specific business logic

Phase 3: Backend Integration Analysis
API Layer Review

 Identify REST/GraphQL endpoint patterns
 Document authentication and authorization requirements
 Map CRUD operation availability
 Review error handling patterns

Database Layer Review

 Analyze data models and relationships
 Identify foreign key constraints
 Review indexing and query optimization
 Document validation rules

Phase 4: Data Flow Mapping
Data Fetching Operations

 List all GET endpoint patterns
 Document response data structures
 Identify pagination and filtering parameters
 Map real-time data requirements

Data Mutation Operations

 List all POST/PUT/PATCH/DELETE endpoints
 Document required payload structures
 Identify validation and sanitization requirements
 Map batch operation capabilities

Phase 5: Implementation Strategy

 Plan CSS class preservation with exact order maintenance
 Design backwards-compatible data synchronization
 Plan component update sequence to avoid breaking changes
 Identify rollback strategies for each change

Phase 6: Quality Assurance

 Verify all original CSS classes are preserved in exact order
 Confirm API contract compatibility
 Test data integrity across all operations
 Validate styling consistency across component variants
 Ensure responsive design patterns are maintained

----
Pause here!
check if your prompts were contradictive

------
Universal Application Protocol:
This checklist applies to any component modification request, ensuring:

Database schema compliance
API contract adherence
CSS class order preservation
Data flow integrity
Backwards compatibility
---

### üß† Generalized Copilot Prompting Strategy for Context + Performance Issues

1. **Find the relevant file:**

   ```
   Locate the file where this component or feature is implemented.
   ```

2. **Read the contents:**

   ```
   Show me the code inside that file so I can understand how it‚Äôs structured and what it depends on.
   ```

3. **Analyze context usage:**

   ```
   Identify where and how any context provider or consumer is used in this component. Is it deeply nested, passed around, or triggering rerenders?
   ```

4. **Spot performance red flags:**

   ```
   Point out any potential performance issues here ‚Äî excessive re-renders, state bloat, overuse of context, or unnecessary recalculations.
   ```

5. **Outline a refactor strategy:**

   ```
   Suggest a cleaner or more efficient way to structure this component, with minimal changes, to address the performance concerns you identified.
   ```

6. **Generate improved implementation:**

   ```
   Rewrite the key parts of the component using that improved strategy. Make it scalable and easy to maintain.
   ```

7. **Testing and validation:**

   ```
   What tests or validations should I do to confirm this refactor doesn't break functionality and actually improves performance?
   ```

8. **Performance benchmarking:**

   ```
   How can I benchmark this component before and after the changes to quantify performance gains (e.g., render counts, interaction delay)?
   ```

---


after this, answer the following !important


WINGMAN CODEBASE COMPREHENSIVE AUDIT CHECKLIST
==============================================

üîç CORE APPLICATION STRUCTURE
-----------------------------

1. MAIN ENTRY POINTS
- [ ] `src/main.tsx` - React app entry point mounts App to DOM
  - [ ] Correct imports (React, ReactDOM, App)
  - [ ] No unnecessary exports
  - [ ] No critical issues present
  - [ ] No unused variables
  - [ ] Clear render logic

- [ ] `App.tsx` - Root component
  - [ ] Imports React Router, context providers, components
  - [ ] Default export present
  - [ ] `setUser` implemented correctly
  - [ ] Backend health check active and functional
  - [ ] State variables named meaningfully
  - [ ] `useEffect` dependencies complete and correct
  - [ ] No use of `any` in TypeScript without justification

- [ ] `index.html` - HTML Template
  - [ ] Proper HTML5 structure
  - [ ] React root div present
  - [ ] Clean, minimal, semantic HTML

üèóÔ∏è COMPONENT ARCHITECTURE
--------------------------

2. CALENDAR COMPONENTS
- [ ] `DayView.tsx`
  - [ ] Correct imports (hooks, routing, context, types)
  - [ ] Default export
  - [ ] Modern Button usage consistent
  - [ ] Async ops and error handling implemented
  - [ ] All props/types used
  - [ ] No dead JSX branches or unreachable code
  - [ ] Loading and empty states handled

- [ ] `WeekView.tsx`
  - [ ] Correct imports
  - [ ] Default export
  - [ ] Performance optimized with React.memo
  - [ ] Renders correctly for different week spans
  - [ ] Linting passes cleanly

- [ ] `TaskItem.tsx`
  - [ ] Displays task info, urgency, icons
  - [ ] Proper event handling
  - [ ] No hardcoded styles inside logic

- [ ] `TaskForm.tsx`
  - [ ] Handles task creation/editing with validation
  - [ ] Prevents double-submission
  - [ ] Calculates urgency
  - [ ] Field reset/clearing works after submit
  - [ ] State hooks cleanly managed

3. STYLING FILES
- [ ] `WeekView.css`
- [ ] `TaskForm.css`
- [ ] `TaskItem.css`
- [ ] `Button.css`
  - [ ] No duplicate or dead class names
  - [ ] Consistent naming conventions (e.g., kebab-case or camelCase)
  - [ ] Mobile responsiveness checked
  - [ ] `:hover`, `:focus`, `:active` states consistent
  - [ ] Dark mode (if supported) has contrast-safe colors

üîß UTILITY & CONFIGURATION
--------------------------

4. CONFIGURATION FILES
- [ ] `config.ts`
  - [ ] Exports CONFIG, getApiBaseUrl, getApiUrl
  - [ ] Electron environment routing correct
  - [ ] No secrets or hardcoded tokens

- [ ] `vite.config.ts`
  - [ ] Vite + Electron build setup
  - [ ] Proxy for API, build optimizations
  - [ ] Env vars correctly resolved

5. API CLIENT LAYER
- [ ] `apiClient.ts`
  - [ ] Central HTTP client
  - [ ] Imports `getApiUrl` and `Auth` correctly
  - [ ] Auth, retries, deduplication handled
  - [ ] Unused helper functions removed
  - [ ] API errors logged clearly with context

- [ ] `Task.ts`
- [ ] `Calendar.ts`
  - [ ] Task and Event API calls functional
  - [ ] TypeScript interfaces match backend
  - [ ] Optional fields handled safely
  - [ ] No extraneous methods or dead endpoints

üîÑ STATE MANAGEMENT
-------------------

6. CONTEXT PROVIDERS
- [ ] `DataContext.tsx`
  - [ ] Provides data state with caching
  - [ ] Week-based cache, batch ops
  - [ ] Proper error handling
  - [ ] Auth-aware data loading
  - [ ] Fallback/defaults in context
  - [ ] Consumes only needed data in consumers
  - [ ] Uses `useMemo`/`useCallback` for performance

7. CUSTOM HOOKS & UTILITIES
- [ ] `auth.ts`
- [ ] `performance.ts`
- [ ] `debounce.ts`
  - [ ] No unused utilities or legacy code
  - [ ] Hooks return types properly typed
  - [ ] Logging (if present) is toggleable and structured
  - [ ] Clean, DRY implementation

üñ•Ô∏è ELECTRON INTEGRATION
------------------------

8. ELECTRON MAIN PROCESS
- [ ] `main.js`
  - [ ] Spawns backend server
  - [ ] Dev vs prod detection
  - [ ] Correct resource paths
  - [ ] Console logs minimized or wrapped with logger
  - [ ] Event lifecycle clear (`ready`, `window-all-closed`, etc.)

- [ ] `preload.js`
  - [ ] Uses contextBridge securely
  - [ ] Exposes limited API
  - [ ] No unsafe Node.js exposure

9. TYPE DEFINITIONS
- [ ] `electron.d.ts`
- [ ] `vite-env.d.ts`
  - [ ] All global types accurate
  - [ ] No redundant or empty declarations
  - [ ] Type imports/exports clean

üêç BACKEND INTEGRATION
----------------------

10. PYTHON BACKEND
- [ ] `main.py`
  - [ ] FastAPI app with routers
  - [ ] CORS middleware
  - [ ] Health endpoint present
  - [ ] Error messages structured (JSON)
  - [ ] Rate limiting (optional but helpful)

- [ ] `requirements.txt`
  - [ ] All required dependencies pinned
  - [ ] Compatible with Python 3.13
  - [ ] No unnecessary packages

11. BUILD & DEPLOYMENT
- [ ] `package.json`
  - [ ] Dev, build, packaging scripts valid
  - [ ] Dependencies accurate
  - [ ] Electron-builder config present
  - [ ] `scripts` block includes dev, lint, build, package, test
  - [ ] Remove unused packages and scripts

‚ö†Ô∏è CRITICAL ISSUE CHECK
------------------------

HIGH PRIORITY
- [ ] `apiClient.ts` - Missing imports for config and auth
- [ ] `App.tsx` - `setUser` implementation complete
- [ ] `DataContext.tsx` - Has error boundaries
- [ ] `DayView.tsx` - Consistent Button usage

MEDIUM PRIORITY
- [ ] Task interface optional fields consistent
- [ ] Error handling in all async operations
- [ ] Data performance optimized

LOW PRIORITY
- [ ] CSS duplicate styles reviewed
- [ ] JSDoc comments on key logic
- [ ] Standard naming conventions for props, state, and methods

‚úÖ VERIFICATION CHECKLIST
--------------------------
- [ ] TypeScript compiles without error
- [ ] All imports/exports matched
- [ ] No unused variables/functions/modules
- [ ] React component structure clean
- [ ] API client handles auth
- [ ] Context providers functional
- [ ] Electron security enforced
- [ ] Build system complete
- [ ] Python backend properly linked
- [ ] Lint (`eslint`, `flake8`, or `black`) passes
- [ ] Tests (if any) run successfully

üß† DEBUGGING STRATEGY & BLIND SPOTS
-----------------------------------

REASON: Full-stack apps fail where two worlds meet‚Äîcatch assumptions early.

COMMON BLIND SPOTS TO CHECK
- [ ] Frontend ‚Üî Backend endpoint mismatch
- [ ] CORS or preflight errors
- [ ] Async race conditions
- [ ] `useEffect` dependencies
- [ ] API error not shown in UI
- [ ] Dev vs Prod config divergence
- [ ] Supabase RLS policy silently rejecting
- [ ] `console.log()` overload
- [ ] Linting or TS errors ignored
- [ ] State invalidation not triggering re-render
- [ ] Timezones and date handling
- [ ] Electron preload leaks

PREVENTION BEST PRACTICES
- [ ] Add explicit error boundaries in React
- [ ] Use `try/catch` with descriptive error logs
- [ ] Trace each API call with loading + error state
- [ ] Test on both dev and production builds
- [ ] Add API schema validators (Zod/Pydantic)
- [ ] Mock backend responses for frontend testing
- [ ] Define `eslint` and `prettier` rules
- [ ] Run regular dependency audits (`npm audit`, `pip check`)
- [ ] Enable `strict` in `tsconfig.json`

OVERALL STATUS: ____________________________
