
Here's the reorganized schema sorted by categories with their datatypes and RLS policies:

---

### üîê **Authentication & User Management**
#### **users**
- `id` ‚Äì `uuid`
- `name` ‚Äì `text`
- `email` ‚Äì `text`
- `password` ‚Äì `text`
- `created_at` ‚Äì `timestamp`
- `updated_at` ‚Äì `timestamp`
- `username` ‚Äì `text`

**RLS Policies:**
- DELETE: Users can delete their own record (authenticated role)
- INSERT: Users can insert their own record (authenticated role)
- SELECT: Users can select their own record (authenticated role)
- UPDATE: Users can update their own record (authenticated role)

#### **user_settings**
- `id` ‚Äì `uuid`
- `user_id` ‚Äì `uuid`
- `setting_key` ‚Äì `text`
- `setting_value` ‚Äì `text`

**RLS Policies:**
- DELETE: Users can delete their own settings (authenticated role)
- INSERT: Users can insert their own settings (authenticated role)
- SELECT: Users can select their own settings (authenticated role)
- UPDATE: Users can update their own settings (authenticated role)

---

### üí¨ **Chat System**
#### **chat_sessions**
- `id` ‚Äì `uuid`
- `user_id` ‚Äì `uuid`
- `title` ‚Äì `text`
- `started_at` ‚Äì `timestamp`
- `updated_at` ‚Äì `timestamp`

**RLS Policies:**
- DELETE: Users can delete their own chat sessions (authenticated role)
- INSERT: Users can insert their own chat sessions (authenticated role)
- SELECT: Users can select their own chat sessions (authenticated role)
- UPDATE: Users can update their own chat sessions (authenticated role)

#### **chat_messages**
- `id` ‚Äì `uuid`
- `session_id` ‚Äì `uuid`
- `is_ai` ‚Äì `bool`
- `message` ‚Äì `text`
- `timestamp` ‚Äì `timestamp`
- `updated_at` ‚Äì `timestamp`

**RLS Policies:**
- DELETE: Users can delete their own chat messages (authenticated role)
- INSERT: Users can insert their own chat messages (authenticated role)
- SELECT: Users can select their own chat messages (authenticated role)
- UPDATE: Users can update their own chat messages (authenticated role)

#### **chat_history**
- `id` ‚Äì `uuid`
- `user_id` ‚Äì `uuid`
- `message` ‚Äì `text`
- `timestamp` ‚Äì `timestamp`
- `is_ai` ‚Äì `bool`

**RLS Policies:**
- ALL: Users can only access own chat history (public role)

---

### üìÖ **Calendar & Scheduling**
#### **calendar_events**
- `id` ‚Äì `uuid`
- `user_id` ‚Äì `uuid`
- `title` ‚Äì `text`
- `event_date` ‚Äì `date`
- `event_time` ‚Äì `time`
- `type` ‚Äì `text`
- `description` ‚Äì `text`
- `created_at` ‚Äì `timestamp`
- `updated_at` ‚Äì `timestamp`

**RLS Policies:**
- DELETE: Users can delete their own events (authenticated role)
- INSERT: Users can insert their own events (authenticated role)
- SELECT: Users can select their own events (authenticated role)
- UPDATE: Users can update their own events (authenticated role)

#### **tasks**
- `id` ‚Äì `uuid`
- `user_id` ‚Äì `uuid`
- `title` ‚Äì `text`
- `task_date` ‚Äì `date`
- `task_time` ‚Äì `time`
- `completed` ‚Äì `bool`
- `created_at` ‚Äì `timestamp`
- `updated_at` ‚Äì `timestamp`
- `task_type` ‚Äì `text`
- `due_date` ‚Äì `date`
- `last_reset_date` ‚Äì `date`
- `urgency_level` ‚Äì `int`
- `status` ‚Äì `text`

**RLS Policies:**
- ALL: tasks_user_policy (authenticated role)
- DELETE: Users can delete their own tasks (authenticated role)
- INSERT: Users can insert their own tasks (authenticated role)
- SELECT: Users can select their own tasks (authenticated role)
- UPDATE: Users can update their own tasks (authenticated role)

---

### üìî **Personal Journaling**
#### **diary_entries**
- `id` ‚Äì `uuid`
- `user_id` ‚Äì `uuid`
- `entry_date` ‚Äì `date`
- `title` ‚Äì `text`
- `content` ‚Äì `text`
- `mood` ‚Äì `mood_scale`
- `created_at` ‚Äì `timestamp`
- `updated_at` ‚Äì `timestamp`

**RLS Policies:**
- DELETE: Users can delete their own diary entries (authenticated role)
- INSERT: Users can insert their own diary entries (authenticated role)
- SELECT: Users can select their own diary entries (authenticated role)
- UPDATE: Users can update their own diary entries (authenticated role)

--- 



-------------------------------------------------

Existing RLS Policies Descriptions
Users can only access own chat history

Action: ALL
Definition: This policy allows authenticated users to access all records in the chat_history table where the user_id matches the user's ID. This ensures that users can only see their own chat history.
Users can delete their own record

Action: DELETE
Definition: This policy permits authenticated users to delete their own records in the chat_history table, specifically where the id of the record matches the user's ID.
Users can insert their own record

Action: INSERT
Check: This policy allows authenticated users to insert new records into the chat_history table, with a check that ensures the id of the new record matches the user's ID.
Users can select their own record

Action: SELECT
Definition: This policy allows authenticated users to select (read) their own records in the chat_history table, ensuring that they can only access records where the id matches their own.
Users can update their own record

Action: UPDATE
Definition: This policy allows authenticated users to update their own records in the chat_history table, ensuring that they can only modify records where the id matches their own.
Users can delete their own settings

Action: DELETE
Definition: This policy allows authenticated users to delete their own settings in the user_settings table, specifically where the user_id matches the user's ID.
Users can insert their own settings

Action: INSERT
Check: This policy allows authenticated users to insert new settings into the user_settings table, with a check that ensures the user_id of the new setting matches the user's ID.
Users can select their own settings

Action: SELECT
Definition: This policy allows authenticated users to select (read) their own settings in the user_settings table, ensuring that they can only access records where the user_id matches their own.
Users can update their own settings

Action: UPDATE
Definition: This policy allows authenticated users to update their own settings in the user_settings table, ensuring that they can only modify records where the user_id matches their own.
Users can delete their own events

Action: DELETE
Definition: This policy allows authenticated users to delete their own events in the calendar_events table, specifically where the user_id matches the user's ID.
Users can insert their own events

Action: INSERT
Check: This policy allows authenticated users to insert new events into the calendar_events table, with a check that ensures the user_id of the new event matches the user's ID.
Users can select their own events

Action: SELECT
Definition: This policy allows authenticated users to select (read) their own events in the calendar_events table, ensuring that they can only access records where the user_id matches their own.
Users can update their own events

Action: UPDATE
Definition: This policy allows authenticated users to update their own events in the calendar_events table, ensuring that they can only modify records where the user_id matches their own.
Users can delete their own tasks

Action: DELETE
Definition: This policy allows authenticated users to delete their own tasks in the tasks table, specifically where the user_id matches the user's ID.
Users can insert their own tasks

Action: INSERT
Check: This policy allows authenticated users to insert new tasks into the tasks table, with a check that ensures the user_id of the new task matches the user's ID.
Users can select their own tasks

Action: SELECT
Definition: This policy allows authenticated users to select (read) their own tasks in the tasks table, ensuring that they can only access records where the user_id matches their own.
Users can update their own tasks

Action: UPDATE
Definition: This policy allows authenticated users to update their own tasks in the tasks table, ensuring that they can only modify records where the user_id matches their own.
Users can delete their own chat sessions

Action: DELETE
Definition: This policy allows authenticated users to delete their own chat sessions in the chat_sessions table, specifically where the user_id matches the user's ID.
Users can insert their own chat sessions

Action: INSERT
Check: This policy allows authenticated users to insert new chat sessions into the chat_sessions table, with a check that ensures the user_id of the new session matches the user's ID.
Users can select their own chat sessions

Action: SELECT
Definition: This policy allows authenticated users to select (read) their own chat sessions in the chat_sessions table, ensuring that they can only access records where the user_id matches their own.
Users can update their own chat sessions

Action: UPDATE
Definition: This policy allows authenticated users to update their own chat sessions in the chat_sessions table, ensuring that they can only modify records where the user_id matches their own.
Users can delete their own chat messages

Action: DELETE
Definition: This policy allows authenticated users to delete their own chat messages in the chat_messages table, specifically where the session_id corresponds to sessions owned by the user.
**

Tasks
--------------------
create table public.tasks (
  id bigint generated always as identity not null,
  user_id uuid null,
  title text not null,
  task_date date not null,
  task_time time without time zone not null,
  completed boolean null default false,
  created_at timestamp with time zone not null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  task_type text null default 'one-time'::text,
  due_date date null,
  last_reset_date date null,
  urgency_level text null default 'normal'::text,
  status text null default 'active'::text,
  constraint tasks_pkey primary key (id),
  constraint tasks_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint tasks_status_check check (
    (
      status = any (
        array[
          'active'::text,
          'completed'::text,
          'expired'::text
        ]
      )
    )
  ),
  constraint tasks_task_type_check check (
    (
      task_type = any (array['recurring'::text, 'one-time'::text])
    )
  ),
  constraint tasks_urgency_level_check check (
    (
      urgency_level = any (
        array[
          'danger'::text,
          'okay'::text,
          'green'::text,
          'normal'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_tasks_user_date on public.tasks using btree (user_id, task_date) TABLESPACE pg_default;

create index IF not exists idx_tasks_user_id on public.tasks using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_tasks_task_date on public.tasks using btree (task_date) TABLESPACE pg_default;

create trigger update_tasks_timestamp BEFORE
update on tasks for EACH row
execute FUNCTION update_timestamp ();


Events
-----------------------------
create table public.calendar_events (
  id bigint generated always as identity not null,
  user_id uuid null,
  title text not null,
  event_date date not null,
  event_time time without time zone not null,
  type text null,
  description text null,
  created_at timestamp with time zone not null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  constraint calendar_events_pkey primary key (id),
  constraint calendar_events_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint calendar_events_type_check check (
    (
      type = any (
        array[
          'meeting'::text,
          'personal'::text,
          'reminder'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_calendar_events_user_date on public.calendar_events using btree (user_id, event_date) TABLESPACE pg_default;

create index IF not exists idx_calendar_events_user_id on public.calendar_events using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_calendar_events_event_date on public.calendar_events using btree (event_date) TABLESPACE pg_default;

create trigger update_calendar_events_timestamp BEFORE
update on calendar_events for EACH row
execute FUNCTION update_timestamp ();



DIARY Entries
---------------------------
create table public.diary_entries (
  id bigint generated always as identity not null,
  user_id uuid null,
  entry_date date not null,
  title text not null,
  content text not null,
  mood public.mood_scale null,
  created_at timestamp with time zone not null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  constraint diary_entries_pkey primary key (id),
  constraint diary_entries_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_diary_entries_user_id on public.diary_entries using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_diary_entries_entry_date on public.diary_entries using btree (entry_date) TABLESPACE pg_default;

create trigger update_diary_entries_timestamp BEFORE
update on diary_entries for EACH row
execute FUNCTION update_timestamp ();





Users
----------------------
create table public.users (
  id uuid not null default extensions.uuid_generate_v4 (),
  name text null,
  email text not null,
  password text not null,
  created_at timestamp with time zone not null default CURRENT_TIMESTAMP,
  updated_at timestamp with time zone null default CURRENT_TIMESTAMP,
  username text not null,
  constraint users_pkey primary key (id),
  constraint users_email_key unique (email),
  constraint users_username_key unique (username)
) TABLESPACE pg_default;

create trigger update_users_timestamp BEFORE
update on users for EACH row
execute FUNCTION update_timestamp ();