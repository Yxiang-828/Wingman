ðŸ“Š Optimized Week-Based Task Fetching Algorithm
ðŸ§  Core Strategy
The goal is to reduce API calls and memory usage while ensuring a responsive UI. This is done by:

Fetching and caching one week at a time

Using a lightweight format for standard display

Fetching full task details only when necessary

Automatically managing memory by cleaning up old cached weeks

ðŸ”„ PHASE 1: Navigating to a Week
Step 1: Determine the Week ID
When the user navigates to a date (e.g., May 25, 2025), determine the Sunday of that week.

Use this Sunday date as a unique identifier for the week (weekId).

Step 2: Check if Week is Already Cached
Look in your cache to see if data for this weekId already exists.

If it's in the cache and recent, use it directly.

Step 3: If Not Cached, Fetch It
Make a single API call to fetch tasks from Sunday to Saturday of that week.

Only request essential fields needed for display (e.g., id, title, date, time, urgency).

Store this in a memory cache (e.g., a Map keyed by weekId).

Step 4: Display Tasks in UI
Render the lightweight task list per day in the week view from the cache.

Ensure updates or changes to task data are synced into this structure.

ðŸ§¾ PHASE 2: Viewing Task Details
Step 1: User Clicks a Task
When a user selects or clicks a task for more info, trigger a detail fetch.

Step 2: Check if Full Details Are Already Loaded
If this taskâ€™s full info is already present (e.g., previously opened), skip the fetch.

Step 3: Fetch Full Task Details (On-Demand)
Call the backend to get the full task data (including description, notes, tags, etc.).

Cache this result locally for subsequent views.

ðŸ§¹ PHASE 3: Smart Cache Management
Step 1: Keep the Most Recent 5 Weeks
Keep a rolling window of 5 cached weeks (current week Â± 2 weeks before/after).

This ensures fast navigation near the current date.

Step 2: Clean Up Old Data
If more than 5 weeks are cached, remove the oldest (least recently accessed).

Use a Least Recently Used (LRU) or timestamp-based cleanup policy.

ðŸ“ˆ Benefits
2 API calls/week max (one for list, one per occasional detail popup)

Snappy UI performance due to reduced fetches

Efficient memory usage via smart week-based caching

Scalable to large numbers of users and tasks