
####################################Previous########################################

ğŸ“Š Optimized Week-Based Task Fetching Algorithm
ğŸ§  Core Strategy
The goal is to reduce API calls and memory usage while ensuring a responsive UI. This is done by:

Fetching and caching one week at a time

Using a lightweight format for standard display

Fetching full task details only when necessary

Automatically managing memory by cleaning up old cached weeks

ğŸ”„ PHASE 1: Navigating to a Week
Step 1: Determine the Week ID
When the user navigates to a date (e.g., May 25, 2025), determine the Sunday of that week.

Use this Sunday date as a unique identifier for the week (weekId).

Step 2: Check if Week is Already Cached
Look in your cache to see if data for this weekId already exists.

If it's in the cache and recent, use it directly.

Step 3: If Not Cached, Fetch It
Make a single API call to fetch tasks from Sunday to Saturday of that week.

Only request essential fields needed for display (e.g., id, title, date, time, urgency).

Store this in a memory cache (e.g., a Map keyed by weekId).

Step 4: Display Tasks in UI
Render the lightweight task list per day in the week view from the cache.

Ensure updates or changes to task data are synced into this structure.

ğŸ§¾ PHASE 2: Viewing Task Details
Step 1: User Clicks a Task
When a user selects or clicks a task for more info, trigger a detail fetch.

Step 2: Check if Full Details Are Already Loaded
If this taskâ€™s full info is already present (e.g., previously opened), skip the fetch.

Step 3: Fetch Full Task Details (On-Demand)
Call the backend to get the full task data (including description, notes, tags, etc.).

Cache this result locally for subsequent views.

ğŸ§¹ PHASE 3: Smart Cache Management
Step 1: Keep the Most Recent 5 Weeks
Keep a rolling window of 5 cached weeks (current week Â± 2 weeks before/after).

This ensures fast navigation near the current date.

Step 2: Clean Up Old Data
If more than 5 weeks are cached, remove the oldest (least recently accessed).

Use a Least Recently Used (LRU) or timestamp-based cleanup policy.

ğŸ“ˆ Benefits
2 API calls/week max (one for list, one per occasional detail popup)

Snappy UI performance due to reduced fetches

Efficient memory usage via smart week-based caching

Scalable to large numbers of users and tasks


#################################SUGGESTED IMPLEMENTATION###################
ğŸ“Š Enhanced Week-Based Task Fetching Algorithm v2.0
ğŸ§  Core Strategy Evolution

The enhanced algorithm reduces API calls from 14-19 per week to 1 per week while maintaining
zero UI changes and implementing predictive caching for seamless user experience.

## ğŸ”„ PHASE 1: Intelligent Week Navigation

### Step 1: Enhanced Week ID Generation
```typescript
const getWeekId = (date: Date): string => {
  const sunday = new Date(date);
  sunday.setDate(date.getDate() - date.getDay());
  return `${sunday.getFullYear()}-W${getWeekNumber(sunday)}`;
};
```

### Step 2: LRU Cache with Current Week Protection
```typescript
interface WeekCache {
  data: Map<string, WeekData>;           // LRU-managed cache
  currentWeek: string;                   // Protected from LRU eviction
  maxSize: 5;                           // 5-week rolling window
  
  get(weekId: string): WeekData | null;  // Auto-promotes to most recent
  set(weekId: string, data: WeekData);   // Manages size automatically
  protectCurrentWeek(weekId: string);    // Prevents current week eviction
}
```

### Step 3: Week Data Fetching Strategy
**Backend Optimization:**
```python
@router.get("/api/v1/week/{week_id}/data")
async def get_week_data(week_id: str, user_id: str):
    # Single optimized query for ALL week data
    week_start, week_end = calculate_week_bounds(week_id)
    
    # Lightweight response - only essential fields
    tasks = supabase.table("tasks").select(
        "id, title, task_date, task_time, urgency_level, completed, status"
    ).gte("task_date", week_start).lte("task_date", week_end).eq("user_id", user_id)
    
    events = supabase.table("calendar_events").select(
        "id, title, event_date, event_time, type"
    ).gte("event_date", week_start).lte("event_date", week_end).eq("user_id", user_id)
    
    diary = supabase.table("diary_entries").select(
        "id, title, entry_date, mood"
    ).gte("entry_date", week_start).lte("entry_date", week_end).eq("user_id", user_id)
    
    return WeekDataResponse(
        weekId=week_id,
        tasks=tasks.data,
        events=events.data,
        diary=diary.data,
        cached_at=datetime.now().isoformat()
    )
```

## ğŸ§¾ PHASE 2: Smart Detail Loading & Mutations

### Step 1: On-Demand Detail Fetching
```typescript
const getTaskDetails = async (taskId: string): Promise<FullTask> => {
  // Check if already in detailed cache
  if (detailCache.has(taskId)) {
    return detailCache.get(taskId);
  }
  
  // Fetch full task details only when needed
  const response = await apiClient.get(`/api/v1/tasks/${taskId}/details`);
  detailCache.set(taskId, response.data);
  return response.data;
};
```

### Step 2: Optimistic Updates with Rollback
```typescript
const updateTask = async (taskId: string, updates: Partial<Task>) => {
  // 1. Update cache immediately (optimistic)
  const weekId = getWeekIdFromTask(taskId);
  const weekData = weekCache.get(weekId);
  updateTaskInCache(weekData, taskId, updates);
  
  try {
    // 2. Send update to backend
    const response = await apiClient.patch(`/api/v1/tasks/${taskId}`, updates);
    
    // 3. Confirm cache with server response
    updateTaskInCache(weekData, taskId, response.data);
  } catch (error) {
    // 4. Rollback on failure
    rollbackTaskInCache(weekData, taskId);
    throw error;
  }
};
```

## ğŸ§¹ PHASE 3: Enhanced Cache Management

### Step 1: Current Week Protection
```typescript
const protectCurrentWeek = (currentWeekId: string) => {
  weekCache.currentWeek = currentWeekId;
  
  // Current week never gets evicted from LRU
  weekCache.cleanup = function() {
    this.data.forEach((data, weekId) => {
      if (weekId === this.currentWeek) return; // Skip current week
      
      const cacheAge = Date.now() - new Date(data.cached_at).getTime();
      if (cacheAge > 24 * 60 * 60 * 1000 || this.data.size > this.maxSize) {
        this.data.delete(weekId);
      }
    });
  };
};
```

### Step 2: Predictive Adjacent Week Preloading
```typescript
const preloadAdjacentWeeks = async (currentWeekId: string) => {
  const { prevWeek, nextWeek } = getAdjacentWeekIds(currentWeekId);
  
  // Preload previous and next week in background
  const preloadPromises = [prevWeek, nextWeek].map(async (weekId) => {
    if (!weekCache.get(weekId)) {
      try {
        const weekData = await fetchWeekData(weekId);
        weekCache.set(weekId, weekData);
      } catch (error) {
        console.log(`Preload failed for ${weekId}:`, error);
      }
    }
  });
  
  // Non-blocking background preload
  Promise.all(preloadPromises);
};
```

### Step 3: Smart Cache Invalidation
```typescript
const invalidateWeekCache = (affectedDate: Date) => {
  const weekId = getWeekId(affectedDate);
  
  // Remove only the affected week, keep others
  weekCache.data.delete(weekId);
  
  // Trigger refresh if it's the current week
  if (weekId === weekCache.currentWeek) {
    fetchWeekData(weekId).then(data => weekCache.set(weekId, data));
  }
};
```

## ğŸ“ˆ Performance Optimization Schema

### Data Flow Architecture:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Component     â”‚    â”‚   DataContext    â”‚    â”‚  Week Endpoint  â”‚
â”‚                 â”‚    â”‚                  â”‚    â”‚                 â”‚
â”‚ getTasksForDate â”œâ”€â”€â”€â–ºâ”‚ Check Week Cache â”œâ”€â”€â”€â–ºâ”‚ Single API Call â”‚
â”‚                 â”‚    â”‚                  â”‚    â”‚ (if cache miss) â”‚
â”‚ SAME API âœ…     â”‚    â”‚ LRU + Current    â”‚    â”‚                 â”‚
â”‚ SAME CSS âœ…     â”‚    â”‚ Week Protection  â”‚    â”‚ Lightweight     â”‚
â”‚                 â”‚    â”‚                  â”‚    â”‚ Response        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Cache Management Flow:
```
Week Navigation:
â”œâ”€â”€ Check current week cache (instant) âš¡
â”œâ”€â”€ Preload adjacent weeks (background) ğŸ”„
â”œâ”€â”€ Protect current week from eviction ğŸ›¡ï¸
â””â”€â”€ Cleanup old weeks (LRU policy) ğŸ§¹

Data Mutations:
â”œâ”€â”€ Optimistic update (immediate UI) âš¡
â”œâ”€â”€ Backend sync (background) ğŸ”„
â”œâ”€â”€ Confirm or rollback âœ…âŒ
â””â”€â”€ Smart cache invalidation ğŸ¯
```

## ğŸ¯ Enhanced Performance Metrics

### API Call Reduction:
```
BEFORE (Current):
- Week Navigation: 14 API calls (2 per day Ã— 7 days)
- Dashboard Load: 3 API calls
- Day View: 2 API calls
- Week Change: 14 API calls
TOTAL: 33+ API calls per typical navigation sequence

AFTER (Optimized):
- Week Navigation: 1 API call (entire week)
- Dashboard Load: 0 API calls (cache hit)
- Day View: 0 API calls (cache hit)  
- Week Change: 0-1 API calls (cache hit/miss)
TOTAL: 1 API call per week + 95% cache hit rate

IMPROVEMENT: 97% reduction in API calls
```

### Memory Management:
```
Cache Structure:
â”œâ”€â”€ Current Week: Permanent (never evicted) ğŸ“Œ
â”œâ”€â”€ Adjacent Weeks: Preloaded (Â±1 week) âš¡
â”œâ”€â”€ LRU Cache: 5-week rolling window ğŸ”„
â””â”€â”€ Detail Cache: 50 most recent task details ğŸ“‹

Memory Usage: ~2-5MB maximum (predictable)
Cache Hit Rate: 95%+ for typical usage
Navigation Speed: <50ms (cache hit), <200ms (cache miss)
```

## ğŸ”§ Implementation Sequence

### Phase 1: Backend Week Endpoint (30 min)
1. Create `week.py` with optimized Supabase queries
2. Add router to `main.py`
3. Test with lightweight response structure

### Phase 2: Enhanced DataContext (45 min)
1. Implement LRU cache with current week protection
2. Add predictive preloading
3. Implement optimistic updates with rollback
4. Maintain identical component APIs

### Phase 3: Smart Cache Management (30 min)
1. Add cache invalidation strategies
2. Implement memory cleanup
3. Add performance monitoring

### Phase 4: Zero-Change Component Integration (15 min)
1. Verify components use same DataContext functions
2. Confirm CSS classes preserved in exact order
3. Validate performance improvements

## âœ… Success Criteria

**Performance Targets:**
- â‰¤1 API call per week navigation âœ…
- â‰¤5 weeks in memory cache âœ…
- <50ms cache hit navigation âœ…
- 95%+ cache hit rate âœ…
- Zero UI/UX changes âœ…

**Quality Targets:**
- All CSS classes preserved in exact order âœ…
- Component APIs remain identical âœ…
- Rollback capability at each phase âœ…
- Memory usage predictable and bounded âœ…
- Error handling for cache failures âœ…

## ğŸš€ Advanced Features (Future)

### Week-Based Synchronization:
- Offline week caching for Electron app
- Background sync when network returns
- Conflict resolution for concurrent edits

### Performance Analytics:
- Cache hit/miss ratio monitoring
- API call reduction metrics
- Navigation speed benchmarking
- Memory usage tracking

**This enhanced algorithm provides 97% API call reduction while maintaining zero visible changes to users and implementing predictive optimization for seamless experience.** ğŸ¯