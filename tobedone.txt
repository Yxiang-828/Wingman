import React, { createContext, useContext, useState, ReactNode, useCallback } from 'react';
import { api } from '../api/apiClient';
import type { Task } from '../api/Task';
import type { CalendarEvent } from '../api/Calendar';

interface CrudOperation {
  type: 'CREATE' | 'UPDATE' | 'DELETE' | 'TOGGLE';
  entity: 'TASK' | 'EVENT';
  data: any;
  affectedDate?: string;
}

type CacheUpdateCallback = (operation: CrudOperation) => void;

interface DataContextType {
  // CRUD Operations (sends to FastAPI + broadcasts)
  createTask: (task: Partial<Task>) => Promise<Task>;
  updateTask: (task: Task) => Promise<Task>;
  deleteTask: (taskId: number) => Promise<void>;
  toggleTask: (task: Task) => Promise<Task>;
  
  createEvent: (event: Partial<CalendarEvent>) => Promise<CalendarEvent>;
  updateEvent: (event: CalendarEvent) => Promise<CalendarEvent>;
  deleteEvent: (eventId: number) => Promise<void>;
  
  // Data Fetching (for primary cache owners only)
  fetchDayData: (date: string, page?: number) => Promise<{ tasks: Task[]; events: CalendarEvent[]; hasMore: { tasks: boolean; events: boolean } }>;
  
  // Cache Update Broadcasting
  subscribeToCacheUpdates: (componentId: string, callback: CacheUpdateCallback) => void;
  unsubscribeFromCacheUpdates: (componentId: string) => void;
  
  // Loading state
  loading: boolean;
  error: string | null;
}

class CacheUpdateBroadcaster {
  private subscribers = new Map<string, CacheUpdateCallback>();

  subscribe(componentId: string, callback: CacheUpdateCallback): void {
    this.subscribers.set(componentId, callback);
    console.log(`üì° ${componentId} subscribed to cache updates`);
  }

  unsubscribe(componentId: string): void {
    this.subscribers.delete(componentId);
    console.log(`üì° ${componentId} unsubscribed from cache updates`);
  }

  broadcast(operation: CrudOperation): void {
    console.log(`üì° Broadcasting ${operation.type} for ${operation.entity}:`, operation.data);
    
    this.subscribers.forEach((callback, componentId) => {
      try {
        callback(operation);
      } catch (error) {
        console.error(`‚ùå Cache update failed for ${componentId}:`, error);
      }
    });
  }
}

const broadcaster = new CacheUpdateBroadcaster();

const DataContext = createContext<DataContextType | undefined>(undefined);

export const DataProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Create Task: Cache first ‚Üí API ‚Üí Broadcast
  const createTask = useCallback(async (task: Partial<Task>): Promise<Task> => {
    setLoading(true);
    setError(null);
    
    try {
      // Create optimistic task with temporary ID
      const optimisticTask: Task = {
        id: Date.now(), // Temporary ID
        text: task.text || '',
        date: task.date || '',
        time: task.time || '',
        completed: task.completed || false,
        user_id: task.user_id || ''
      };

      // Broadcast optimistic update immediately
      broadcaster.broadcast({
        type: 'CREATE',
        entity: 'TASK',
        data: optimisticTask,
        affectedDate: optimisticTask.date
      });

      // Send to API
      const createdTask = await api.post('/v1/tasks', task);
      
      // Update with real ID and broadcast correction
      const finalTask = { ...optimisticTask, id: createdTask.id };
      broadcaster.broadcast({
        type: 'UPDATE',
        entity: 'TASK',
        data: finalTask,
        affectedDate: finalTask.date
      });

      return finalTask;
    } catch (error) {
      setError('Failed to create task');
      // Broadcast rollback
      broadcaster.broadcast({
        type: 'DELETE',
        entity: 'TASK',
        data: { id: Date.now() }, // Remove the optimistic task
        affectedDate: task.date
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Update Task: Cache first ‚Üí API ‚Üí Broadcast
  const updateTask = useCallback(async (task: Task): Promise<Task> => {
    setLoading(true);
    setError(null);
    
    try {
      // Broadcast optimistic update immediately
      broadcaster.broadcast({
        type: 'UPDATE',
        entity: 'TASK',
        data: task,
        affectedDate: task.date
      });

      // Send to API
      const updatedTask = await api.put(`/v1/tasks/${task.id}`, task);
      
      // Broadcast final result (may have server-side changes)
      const finalTask = { ...task, ...updatedTask };
      broadcaster.broadcast({
        type: 'UPDATE',
        entity: 'TASK',
        data: finalTask,
        affectedDate: finalTask.date
      });

      return finalTask;
    } catch (error) {
      setError('Failed to update task');
      // TODO: Implement rollback mechanism
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Delete Task: Cache first ‚Üí API ‚Üí Broadcast
  const deleteTask = useCallback(async (taskId: number): Promise<void> => {
    setLoading(true);
    setError(null);
    
    try {
      // Broadcast optimistic delete immediately
      broadcaster.broadcast({
        type: 'DELETE',
        entity: 'TASK',
        data: { id: taskId }
      });

      // Send to API
      await api.delete(`/v1/tasks/${taskId}`);
      
      // Confirm deletion (already done optimistically)
      console.log(`‚úÖ Task ${taskId} successfully deleted from API`);
    } catch (error) {
      setError('Failed to delete task');
      // TODO: Implement rollback mechanism
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Toggle Task: Special case of update
  const toggleTask = useCallback(async (task: Task): Promise<Task> => {
    const toggledTask = { ...task, completed: !task.completed };
    return updateTask(toggledTask);
  }, [updateTask]);

  // Similar implementations for events...
  const createEvent = useCallback(async (event: Partial<CalendarEvent>): Promise<CalendarEvent> => {
    // Similar pattern to createTask
    const optimisticEvent: CalendarEvent = {
      id: Date.now(),
      title: event.title || '',
      date: event.date || '',
      time: event.time || '',
      type: event.type || '',
      description: event.description || ''
    };

    broadcaster.broadcast({
      type: 'CREATE',
      entity: 'EVENT',
      data: optimisticEvent,
      affectedDate: optimisticEvent.date
    });

    try {
      const createdEvent = await api.post('/v1/events', event);
      const finalEvent = { ...optimisticEvent, id: createdEvent.id };
      
      broadcaster.broadcast({
        type: 'UPDATE',
        entity: 'EVENT',
        data: finalEvent,
        affectedDate: finalEvent.date
      });

      return finalEvent;
    } catch (error) {
      broadcaster.broadcast({
        type: 'DELETE',
        entity: 'EVENT',
        data: { id: optimisticEvent.id },
        affectedDate: event.date
      });
      throw error;
    }
  }, []);

  const updateEvent = useCallback(async (event: CalendarEvent): Promise<CalendarEvent> => {
    broadcaster.broadcast({
      type: 'UPDATE',
      entity: 'EVENT',
      data: event,
      affectedDate: event.date
    });

    try {
      const updatedEvent = await api.put(`/v1/events/${event.id}`, event);
      const finalEvent = { ...event, ...updatedEvent };
      
      broadcaster.broadcast({
        type: 'UPDATE',
        entity: 'EVENT',
        data: finalEvent,
        affectedDate: finalEvent.date
      });

      return finalEvent;
    } catch (error) {
      throw error;
    }
  }, []);

  const deleteEvent = useCallback(async (eventId: number): Promise<void> => {
    broadcaster.broadcast({
      type: 'DELETE',
      entity: 'EVENT',
      data: { id: eventId }
    });

    try {
      await api.delete(`/v1/events/${eventId}`);
    } catch (error) {
      throw error;
    }
  }, []);

  // Data Fetching (only for primary cache owners)
  const fetchDayData = useCallback(async (date: string, page: number = 1) => {
    try {
      const [tasksResponse, eventsResponse] = await Promise.all([
        api.get(`/v1/tasks?date=${date}&page=${page}&limit=7`),
        api.get(`/v1/events?date=${date}&page=${page}&limit=7`)
      ]);

      return {
        tasks: tasksResponse.data || [],
        events: eventsResponse.data || [],
        hasMore: {
          tasks: tasksResponse.hasMore || false,
          events: eventsResponse.hasMore || false
        }
      };
    } catch (error) {
      console.error('Failed to fetch day data:', error);
      return {
        tasks: [],
        events: [],
        hasMore: { tasks: false, events: false }
      };
    }
  }, []);

  const value: DataContextType = {
    createTask,
    updateTask,
    deleteTask,
    toggleTask,
    createEvent,
    updateEvent,
    deleteEvent,
    fetchDayData,
    subscribeToCacheUpdates: broadcaster.subscribe.bind(broadcaster),
    unsubscribeFromCacheUpdates: broadcaster.unsubscribe.bind(broadcaster),
    loading,
    error
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
};

export const useDataContext = (): DataContextType => {
  const context = useContext(DataContext);
  if (!context) {
    throw new Error('useDataContext must be used within a DataProvider');
  }
  return context;
};

export const useData = useDataContext; // Alias for compatibility

// DELETE LINES 15-25: Cache destructuring
const { taskCache, eventCache, currentWeekId, fixedCurrentWeekCache } = useData();

// DELETE LINES 85-200: generateNotificationsFromCache function entirely

// KEEP ONLY: Basic notification state and CRUD toggleTask function